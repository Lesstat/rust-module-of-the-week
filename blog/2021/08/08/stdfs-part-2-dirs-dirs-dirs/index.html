<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <meta name="author" content="RMOTW Contributors" />
    <meta name="copyright" content="RMOTW Contributors" />


<meta name="keywords" content="motw, fs, easy, path, files, directories, Module of the Week, " />

    <title>std::fs (Part 2): Dirs, Dirs, Dirs  · Rust Module of the Week
</title>


    <link href="https://motw.rs/rss.xml" type="application/rss+xml" rel="alternate" title="Rust Module of the Week - Full RSS Feed" />
    <link href="https://motw.rs/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Rust Module of the Week - Full Atom Feed" />

    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css">

    <link rel="stylesheet" href="https://motw.rs/theme/css/web-min.css?2fe77f69">
    <link rel="icon" type="image/png" sizes="32x32" href="https://www.rust-lang.org/static/images/favicon-32x32.png">
    <link rel="icon" type="image/svg+xml" href="https://www.rust-lang.org/static/images/favicon.svg">
    <link rel="mask-icon" href="https://www.rust-lang.org/static/images/safari-pinned-tab.svg" color="#000">

  </head>
  <body>
    <header class="site-header">
      <div class="container wrapper">
        <a class="site-title" href="https://motw.rs/">Rust Module of the Week</a>
      </div>
    </header>

    <div class="page-content">
      <div class="container wrapper">
<div class="post">
  <header class="post-header">
<div class="row post-title">
    <div class="col-xs-12 col-sm-4">
      <span class="small text-muted time-prefix">
        <time pubdate="pubdate" datetime="2021-08-08T09:57:00-04:00">08 AUG 2021</time>
      </span>
    </div>
    <div class="col-xs-12 col-sm-8 text-right custom-xs-text-left">
      <a href="https://motw.rs/blog/2021/08/08/stdfs-part-2-dirs-dirs-dirs/">std::fs (Part 2): Dirs, Dirs, Dirs</a>
    </div>
  </div>
    </header>

<nav class="post-neighbors panel">
    <div class="col-md-4">
    <a  class="neighbor prev-article" href="https://motw.rs/blog/2021/08/01/stdfs-part-1/">
        <span class="neighbor-arrow">«</span>
        <span class="neighbor-content">
            <span class="neighbor-label">Previous:</span>
            <span class="neighbor-title">std::fs (Part 1)</span>
        </span>
    </a>
    </div>
    <div class="col-md-4 text-center">
        <div class="col-md-12">
            <div class="row"><span><code>std::fs</code> series</span></div>
            <div class="row"><span>Part 2 of 2</span></div>
            
        </div>
    </div>
    <div class="col-md-4">
    </div>
</nav>

  <article class="post-content">
    <p>Welcome back to to MOTW! This week, we'll be continuing from <a href="{filename}/2021-08-01-rmotw.md" title="part 1">part 1</a>, exploring some more of <code>std::fs</code>. Let's see what Rudgal has been up to!</p>
<!-- more -->

<h1>The module</h1>
<p><a href="https://doc.rust-lang.org/std/fs/index.html" referrerpolicy="no-referrer" rel="noopener noreferrer" target="_blank" title="std::fs">std::fs</a> is the standard Rust module for interacting with a Filesystem. It handles a lot of the messy work when it comes to all the different ways that the underlying OS likes to handle files. Creating, Reading, Updating, Deleting, it's all there! Not every operation is supported by every OS, but this guide will try to remain as platform agnostic as possible. </p>
<h1>The story so far</h1>
<p><a href="https://www.fantasynamegenerators.com/dnd-orc-names.php" referrerpolicy="no-referrer" rel="noopener noreferrer" target="_blank" title="Rudgal The Delirious">Rudgal The Delirious</a> is the local Ornithologist. Armed with his trusty camera he's been tasked by the local Government to catalog and identify all of the birds in his local area. As he has to identify not only the species but the individual birds he's ended up with quite a few photos!</p>
<p>Last week Rudgal had laid the groundwork for his photo-reoganizing project. Files were filtered, directories iterated and recursed. But not <em>that</em> kind of curse. Yet.</p>
<h2>Grouping files by modification time</h2>
<p>Rudgal had decided that the most optimal and efficient way to sort these photos was to group them by the year, month and day that they were taken. After perusing the <a href="https://doc.rust-lang.org/stable/std/fs/struct.Metadata.html" title="metadata docs">metadata docs</a> the closest thing he could find was the <a href="https://doc.rust-lang.org/stable/std/fs/struct.Metadata.html#method.modified" title="modified">modified</a> function, which returns a <a href="https://doc.rust-lang.org/stable/std/time/struct.SystemTime.html" title="SystemTime">SystemTime</a> struct.</p>
<p>After consulting <a href="https://www.fantasynamegenerators.com/wizard-names.php" referrerpolicy="no-referrer" rel="noopener noreferrer" target="_blank" title="Suwyss the Mathematical">Suwyss the Mathematical</a>'s <em>Guide to Time Magic</em>, he was able to put together a pretty decent function to convert from <code>SystemTime</code> to something far more useful.</p>
<p>First! The far more useful part.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Let Rust derive all the things I need for BTreeMap</span>
<span class="cp">#[derive(PartialEq, Eq, PartialOrd, Ord, Debug)]</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">RudgalDate</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">year</span>: <span class="kt">u64</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">month</span>: <span class="kt">u64</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">day</span>: <span class="kt">u64</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>Meet <code>RudgalDate</code>, the totally original and useful structure for grouping files together. Note especially the <code>derive</code> line. <code>PartialEq</code>, <code>Eq</code>, <code>PartialOrd</code>, <code>Ord</code> are useful when you want to use a <code>struct</code> as a key in order to sort some things. Say, in something that could group things together by said key. More on that later! First, Rudgal needs to convert from <code>SystemTime</code> to his <code>RudgalDate</code>:</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In Rudgal's world there are no such things as leap days, leap seconds, or timezones. They <em>do</em> exist in our world so taking this approach is <strong>not recommended</strong>. Use the <a href="https://crates.io/crates/chrono" referrerpolicy="no-referrer" rel="noopener noreferrer" target="_blank" title="chrono">chrono</a> crate for real-world scenarios.</p>
</div>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="n">YEAR_SECONDS</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="mi">31556926</span><span class="p">;</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">MONTH_SECONDS</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="mi">2629743</span><span class="p">;</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">DAY_SECONDS</span>: <span class="kt">u64</span> <span class="o">=</span><span class="w"> </span><span class="mi">86400</span><span class="p">;</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">systime_to_tuple</span><span class="p">(</span><span class="n">t</span>: <span class="nc">SystemTime</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">RudgalDate</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// This is an approximate, do not use in any sort of production</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">secs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">.</span><span class="n">duration_since</span><span class="p">(</span><span class="n">SystemTime</span>::<span class="n">UNIX_EPOCH</span><span class="p">).</span><span class="n">unwrap</span><span class="p">().</span><span class="n">as_secs</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">years</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">secs</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">YEAR_SECONDS</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">months</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">secs</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">YEAR_SECONDS</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">MONTH_SECONDS</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">days</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">secs</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">YEAR_SECONDS</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">MONTH_SECONDS</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">DAY_SECONDS</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">RudgalDate</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">year</span>:<span class="mi">1970</span><span class="o">+</span><span class="n">years</span><span class="p">,</span><span class="w"> </span>
<span class="w">        </span><span class="n">month</span>: <span class="mi">1</span><span class="o">+</span><span class="n">months</span><span class="p">,</span><span class="w"> </span>
<span class="w">        </span><span class="n">day</span>: <span class="mi">1</span><span class="o">+</span><span class="n">days</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<blockquote>
<p>Good enough for me!</p>
</blockquote>
<p>Said Rudgal, without having written <em>any</em> unit tests.</p>
<p>Now that he had his <code>RudgalDate</code>, it was time to group the files together by said <code>RudgalDate</code>s. After poking around <a href="https://doc.rust-lang.org/stable/std/collections/index.html" title="std::collections">std::collections</a> he came across <a href="https://doc.rust-lang.org/stable/std/collections/struct.BTreeMap.html" title="BTreeMap">BTreeMap</a>. Digging deep into his dusty memories of Structures and Algorithms, he was able to remember that <code>BTreeMap</code>s act like regular <code>Map</code>s, but can keep the <code>Key</code>s in order. Nifty when you're dealing with time!</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">group_files_by_date</span><span class="p">(</span><span class="n">paths</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">PathBuf</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; 
    <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="n">BTreeMap</span><span class="o">&lt;</span><span class="n">RudgalDate</span><span class="p">,</span><span class="w"> </span><span class="n">HashSet</span><span class="o">&lt;</span><span class="n">PathBuf</span><span class="o">&gt;&gt;&gt;</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BTreeMap</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">paths</span><span class="p">.</span><span class="n">clone</span><span class="p">().</span><span class="n">into_iter</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">for_each</span><span class="p">(</span><span class="o">|</span><span class="n">p</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">modified</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fs</span>::<span class="n">metadata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">).</span><span class="n">and_then</span><span class="p">(</span><span class="o">|</span><span class="n">m</span><span class="o">|</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">modified</span><span class="p">()).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="n">entry</span><span class="p">(</span><span class="n">systime_to_tuple</span><span class="p">(</span><span class="n">modified</span><span class="p">))</span><span class="w"></span>
<span class="w">                </span><span class="p">.</span><span class="n">or_insert</span><span class="p">(</span><span class="n">HashSet</span>::<span class="n">new</span><span class="p">());</span><span class="w"></span>
<span class="w">            </span><span class="n">map</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">});</span><span class="w"></span>
<span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>Rudgal sat back in his sustainably-sourced Vegan leather office throne, walking through the code one line at a time to make sure he understood what he had written. He was particularly fond of <a href="https://doc.rust-lang.org/stable/std/collections/struct.BTreeMap.html#method.entry" title="entry">entry</a>.</p>
<blockquote>
<p>Most excellent! It acts like a pointer to a bucket, even if there's <a href="https://doc.rust-lang.org/stable/std/collections/btree_map/enum.Entry.html#method.or_insert" title="nothing in it yet">nothing in it yet</a>!</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="c1">// Rudgal had decided a constant path isn&#39;t very flexible</span>
<span class="kd">let</span><span class="w"> </span><span class="n">image_source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;./images&quot;</span><span class="p">;</span><span class="w"></span>
<span class="c1">// See the last part of std::fs for iter_dirs</span>
<span class="kd">let</span><span class="w"> </span><span class="n">files</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iter_dirs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Path</span>::<span class="n">new</span><span class="p">(</span><span class="n">image_source</span><span class="p">))</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">files_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">files</span><span class="p">.</span><span class="n">len</span><span class="p">();</span><span class="w"></span>
<span class="fm">println!</span><span class="p">(</span><span class="s">&quot;There are {} images!&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">files_count</span><span class="p">);</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">grouped</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">group_files_by_date</span><span class="p">(</span><span class="n">files</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">files_per_key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">grouped</span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">len</span><span class="p">()))</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">collect</span>::<span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span><span class="w"></span>
<span class="fm">println!</span><span class="p">(</span><span class="s">&quot;Some dates from the files are {:?}...&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">files_per_key</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">3</span><span class="p">]);</span><span class="w"></span>
</code></pre></div>

<p>Considering this a good enough test to start with, Rudgal runs the code.</p>
<div class="highlight"><pre><span></span><code>There are <span class="m">10245</span> images!
Some dates from the files are <span class="o">[(</span>RudgalDate <span class="o">{</span> year: <span class="m">2015</span>, month: <span class="m">4</span>, day: <span class="m">3</span> <span class="o">}</span>, <span class="m">84</span><span class="o">)</span>, <span class="o">(</span>RudgalDate <span class="o">{</span> year: <span class="m">2015</span>, month: <span class="m">7</span>, day: <span class="m">30</span> <span class="o">}</span>, <span class="m">85</span><span class="o">)</span>, <span class="o">(</span>RudgalDate <span class="o">{</span> year: <span class="m">2016</span>, month: <span class="m">1</span>, day: <span class="m">9</span> <span class="o">}</span>, <span class="m">76</span><span class="o">)]</span>...
</code></pre></div>

<p>Success!</p>
<h2>Hard linking one path to another</h2>
<p>It's hard for Rudgal to shake his Bureaucratic training. The years studying the tenets of Efficiency with the venerable Monks of Productivity had left their mark.</p>
<blockquote>
<p>I can't just have duplicate photos flying around! That would cost me <em>valuable disk space</em>.</p>
</blockquote>
<p>Gasp, Rudgal. Gasp.</p>
<p>After a thorough <em>several minutes</em> worth of research, he comes across <a href="https://doc.rust-lang.org/stable/std/fs/fn.hard_link.html" title="std::fs::hard_link">std::fs::hard_link</a>. Files in <em>two</em> places?! This is olde Filesystem magic, but it would do. At least while he's testing.</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">link_files</span><span class="p">(</span><span class="n">link_root</span>: <span class="kp">&amp;</span><span class="nc">Path</span><span class="p">,</span><span class="w"> </span><span class="n">files</span>: <span class="kp">&amp;</span><span class="nc">BTreeMap</span><span class="o">&lt;</span><span class="n">RudgalDate</span><span class="p">,</span><span class="w"> </span><span class="n">HashSet</span><span class="o">&lt;</span><span class="n">PathBuf</span><span class="o">&gt;&gt;</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// More to add here later</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">link_root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">link_root</span><span class="p">.</span><span class="n">to_path_buf</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">date</span><span class="p">,</span><span class="w"> </span><span class="n">date_files</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">files</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">link_root</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="fm">format!</span><span class="p">(</span><span class="s">&quot;{}/{}/{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">date</span><span class="p">.</span><span class="n">year</span><span class="p">,</span><span class="w"> </span><span class="n">date</span><span class="p">.</span><span class="n">month</span><span class="p">,</span><span class="w"> </span><span class="n">date</span><span class="p">.</span><span class="n">day</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">date_files</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">link_root</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">file</span><span class="p">.</span><span class="n">file_name</span><span class="p">().</span><span class="n">and_then</span><span class="p">(</span><span class="o">|</span><span class="n">f</span><span class="o">|</span><span class="n">f</span><span class="p">.</span><span class="n">to_str</span><span class="p">()).</span><span class="n">unwrap</span><span class="p">());</span><span class="w"></span>
<span class="w">            </span><span class="n">fs</span>::<span class="n">hard_link</span><span class="p">(</span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">link_root</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">link_root</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Because we add three levels (year, month and day),</span>
<span class="w">        </span><span class="c1">// we have to remove three levels as well!</span>
<span class="w">        </span><span class="n">link_root</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">link_root</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">link_root</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>Running his new code with the highest expectation of excellence, Rudgal soon had his mood crushed like the skulls of so many enemies.</p>
<div class="highlight"><pre><span></span><code>Error: Os <span class="o">{</span> code: <span class="m">2</span>, kind: NotFound, message: <span class="s2">&quot;No such file or directory&quot;</span> <span class="o">}</span>
</code></pre></div>

<blockquote>
<p><code>No such file or directory</code>?! Impossible!</p>
</blockquote>
<p>Easy there, champ. You can fix that.</p>
<h2>Creating directories recursively</h2>
<p>Of course! He simply forgot to create the directories before trying to link the file into that directory. A simple modification to his code (and a touch of <a href="https://doc.rust-lang.org/stable/std/fs/fn.create_dir_all.html" title="create_dir_all">create_dir_all</a>) gave him the fix he needed!</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">date_files</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// Ensure the destination exists already!</span>
<span class="w">    </span><span class="n">fs</span>::<span class="n">create_dir_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">link_root</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">link_root</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">file</span><span class="p">.</span><span class="n">file_name</span><span class="p">().</span><span class="n">and_then</span><span class="p">(</span><span class="o">|</span><span class="n">f</span><span class="o">|</span><span class="n">f</span><span class="p">.</span><span class="n">to_str</span><span class="p">()).</span><span class="n">unwrap</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="n">fs</span>::<span class="n">hard_link</span><span class="p">(</span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">link_root</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">link_root</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>Perfect! Nothing could possibly go wrong this time.</p>
<div class="highlight"><pre><span></span><code>Error: Os <span class="o">{</span> code: <span class="m">17</span>, kind: AlreadyExists, message: <span class="s2">&quot;File exists&quot;</span> <span class="o">}</span>
</code></pre></div>

<p>Oops. Well, at least there's an easy fix to this.</p>
<h2>Deleting a folder recursively</h2>
<p>Rudgal had been running his code repeatedly as he was testing, but it had never occurred to him that he wouldn't be able to have two files occupy the same place.</p>
<blockquote>
<p>Burn it! Raze the directories to the ground!</p>
</blockquote>
<p>Well, electronically speaking. Another modification!</p>
<div class="highlight"><pre><span></span><code><span class="o">..</span><span class="p">.</span><span class="w"></span>
<span class="k">if</span><span class="w"> </span><span class="n">link_root</span><span class="p">.</span><span class="n">exists</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;Removing directory {:?} and everything below it&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">link_root</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">fs</span>::<span class="n">remove_dir_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">link_root</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"> </span>
<span class="p">}</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">link_root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">link_root</span><span class="p">.</span><span class="n">to_path_buf</span><span class="p">();</span><span class="w"></span>
<span class="o">..</span><span class="p">.</span><span class="w"></span>
</code></pre></div>

<p>And with a little code to run it:</p>
<div class="highlight"><pre><span></span><code><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;Linking the pictures&quot;</span><span class="p">);</span><span class="w"></span>
<span class="n">link_files</span><span class="p">(</span><span class="o">&amp;</span><span class="n">image_link_dest</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">grouped</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">link_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iter_dirs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">image_link_dest</span><span class="p">)</span><span class="o">?</span><span class="p">.</span><span class="n">len</span><span class="p">();</span><span class="w"></span>
<span class="fm">println!</span><span class="p">(</span><span class="s">&quot;{} images linked&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">link_count</span><span class="p">);</span><span class="w"></span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>Linking the pictures
Removing directory <span class="s2">&quot;./images_links&quot;</span> and everything below it
<span class="m">10245</span> images linked
</code></pre></div>

<p>Success! Rudgal is now free to explore the folders and ensure that the images were sorted as he desired. Once he was sure, it was time to make the sorting permanent.</p>
<h2>Copying a file</h2>
<p>Now that he was sure he was pleased with the future layout of his photos, Rudgal decided to use <em>precious bytes</em> to copy the files into their new layout. After a few minutes of toying with <a href="https://doc.rust-lang.org/stable/std/fs/fn.copy.html" title="std::fs::copy">std::fs::copy</a>, he realized that his code looked very similar to his approach to linking the file!</p>
<div class="highlight"><pre><span></span><code><span class="k">fn</span> <span class="nf">copy_files</span><span class="p">(</span><span class="n">copy_root</span>: <span class="kp">&amp;</span><span class="nc">Path</span><span class="p">,</span><span class="w"> </span><span class="n">files</span>: <span class="kp">&amp;</span><span class="nc">BTreeMap</span><span class="o">&lt;</span><span class="n">RudgalDate</span><span class="p">,</span><span class="w"> </span><span class="n">HashSet</span><span class="o">&lt;</span><span class="n">PathBuf</span><span class="o">&gt;&gt;</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span>-&gt; <span class="nc">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">copy_root</span><span class="p">.</span><span class="n">exists</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;Removing directory {:?} and everything below it&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">copy_root</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">fs</span>::<span class="n">remove_dir_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">copy_root</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">copy_root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">copy_root</span><span class="p">.</span><span class="n">to_path_buf</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">date</span><span class="p">,</span><span class="w"> </span><span class="n">date_files</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">files</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">copy_root</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="fm">format!</span><span class="p">(</span><span class="s">&quot;{}/{}/{}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">date</span><span class="p">.</span><span class="n">year</span><span class="p">,</span><span class="w"> </span><span class="n">date</span><span class="p">.</span><span class="n">month</span><span class="p">,</span><span class="w"> </span><span class="n">date</span><span class="p">.</span><span class="n">day</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">date_files</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">// Ensure the destination exists already!</span>
<span class="w">            </span><span class="n">fs</span>::<span class="n">create_dir_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">copy_root</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">copy_root</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">file</span><span class="p">.</span><span class="n">file_name</span><span class="p">().</span><span class="n">and_then</span><span class="p">(</span><span class="o">|</span><span class="n">f</span><span class="o">|</span><span class="n">f</span><span class="p">.</span><span class="n">to_str</span><span class="p">()).</span><span class="n">unwrap</span><span class="p">());</span><span class="w"></span>

<span class="w">            </span><span class="c1">// Copy from the original to the newly-sorted path</span>
<span class="w">            </span><span class="n">fs</span>::<span class="n">copy</span><span class="p">(</span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">copy_root</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>

<span class="w">            </span><span class="n">copy_root</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">copy_root</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">copy_root</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">copy_root</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>Having learned his lesson about creating directories and deleting files before running his code again, he was able to skip right to copying the files.  Let's see if he was able to make it work!</p>
<div class="highlight"><pre><span></span><code><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;Copying the pictures&quot;</span><span class="p">);</span><span class="w"></span>
<span class="n">copy_files</span><span class="p">(</span><span class="o">&amp;</span><span class="n">image_dest</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">grouped</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">copied_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iter_dirs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">image_dest</span><span class="p">)</span><span class="o">?</span><span class="p">.</span><span class="n">len</span><span class="p">();</span><span class="w"></span>
<span class="fm">println!</span><span class="p">(</span><span class="s">&quot;{} images copied&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">copied_count</span><span class="p">);</span><span class="w"></span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>Copying the pictures
Removing directory <span class="s2">&quot;./images_sorted&quot;</span> and everything below it
<span class="m">10245</span> images copied
</code></pre></div>

<p>Perfect!</p>
<h1>Conclusion</h1>
<p>This is end of part 2 of <code>std::fs</code>! In this part we covered working with file creation times, directory manipulation, hardlinking files and copying files to new locations. If you'd like to see Rudgal's code for this part, it's posted <a href="https://github.com/slyons/rust-module-of-the-week/blob/main/rmotw/examples/std_fs_2.rs" title="here">here</a>.</p>
<h1>Next week</h1>
<p>Stay tuned next week for the conclusion of <code>std::fs</code>: </p>
<p>File.
Writing.</p>
  </article>
  
  <a href="https://github.com/slyons/rust-module-of-the-week/edit/main/content/2021/08/2021-08-08-rmotw.md">Edit this page on Github</a>

<nav class="post-neighbors panel">
    <div class="col-md-4">
    <a  class="neighbor prev-article" href="https://motw.rs/blog/2021/08/01/stdfs-part-1/">
        <span class="neighbor-arrow">«</span>
        <span class="neighbor-content">
            <span class="neighbor-label">Previous:</span>
            <span class="neighbor-title">std::fs (Part 1)</span>
        </span>
    </a>
    </div>
    <div class="col-md-4 text-center">
        <div class="col-md-12">
            <div class="row"><span><code>std::fs</code> series</span></div>
            <div class="row"><span>Part 2 of 2</span></div>
            
        </div>
    </div>
    <div class="col-md-4">
    </div>
</nav>

<nav class="post-neighbors panel">
  <div class="col-md-4">
  <a  class="neighbor prev-article" href="https://motw.rs/blog/2021/08/01/stdfs-part-1/">
    <span class="neighbor-arrow">«</span>
    <span class="neighbor-content">
      <span class="neighbor-label">Previous:</span>
      <span class="neighbor-title">std::fs (Part 1)</span>
    </span>
  </a>
  </div>
  <div class="col-md-4 text-center">
    <span class="neighbor-content">All articles</span>
  </div>
  <div class="col-md-4">
  </div>
</nav>
</div>
      </div>
    </div>

    <footer>
      <div class="container wrapper">
        <div class="row">
          <div class="col-sm-6 col-xs-12">
            <ul class="list-unstyled">
              <li><a href="https://motw.rs/blog/archives/index.html">past issues</a></li>
              <li><a href="https://motw.rs/feeds/all.atom.xml">atom feed</a></li>
              <li><a href="https://motw.rs/rss.xml">rss feed</a></li>
              <li><a href="https://github.com/slyons/rust-module-of-the-week">source code</a></li>
            </ul>
          </div>
          <div class="col-sm-6 col-xs-12 text-right custom-xs-text-left">
            <ul class="list-unstyled">
              <li><a href="https://motw.rs/pages/privacy-policy.html">privacy policy</a></li>
              <li><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">cc-by-sa-4.0</a></li>
            </ul>
          </div>
        </div>
      </div>
    </footer>
  </body>
</html>